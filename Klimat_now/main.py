# импорт нужных библиотек - отдельная ячейка
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

df = pd.read_csv('Data.csv', sep=";")

# 1.Приведение названий столбцов в соответствии с PEP8 - отдел ячейка
print(' ,'.join(df.columns))  # Видем что названия не соответствуют фармату PEP8, исправим это

df.columns = df.columns.str.replace(' ', '_').str.lower()
print(' ,'.join(df.columns))

# 2.перевод данных к правильному типу - отдел ячейка

# столбец "год" является типом flout.
print(df['год'].dtypes)  #

# приведем к правильному типу, изменив его на int
df['год'] = df['год'].astype('int')
print(df['год'].dtypes)


# 3. удаление дубликатов(категориальных данных) - отдел ячейка
df_no_duplicates = df.drop_duplicates(
    subset=['время_года', 'способ_охлаждения', 'режим_при_смешанном_типе_охлаждения', 'способ_обогрева', 'пол',
            'ощущение_температуры_(bool)', 'предпочтительное_изменение_температуры', 'ощущение_движения_воздуха_(bool)',
            'предпочтительное_изменение_движения_воздуха', 'занавески', 'вентилятор',
            'окно', 'двери', 'отопление'],
    keep=False)

# 4.1 Обработка данных на адекватность данных - отдельная ячейка

# При заполнении данных были совершены опечатки:
# 1 В столбце "климат" - "Субтроп океанич" вместо "Субтропический океанический"
# 2.1 В столбце "предпочтительное_изменение_температуры" - "Тепле" вместо "Теплее"
# 2.2 В столбце "предпочтительное_изменение_температуры" - "Холодн" вместо "Холоднее"

# Исправим их методом loc
df.loc[df['климат'] == 'Субтроп океанич', 'климат'] = 'Субтропический океанический'
df.loc[df['предпочтительное_изменение_температуры'] == 'Тепле', 'предпочтительное_изменение_температуры'] = 'Теплее'
df.loc[df['предпочтительное_изменение_температуры'] == 'Холодн', 'предпочтительное_изменение_температуры'] = 'Холоднее'

# 4.2 Обработка данных на выбросы - отдельная ячейка

# Были найдены выбросы в столбцах: утепление, температура_воздуха_в_помещении, скорость_воздуха, рост, среднемесячная_температура_на_улице.

# Расмотрим их на графиках:

f, a = plt.subplots(1, 5, figsize=(22, 10))
for n, i in enumerate(['утепление', 'температура_воздуха_в_помещении', 'скорость_воздуха', 'рост',
                       'среднемесячная_температура_на_улице']):
    sns.boxplot(y=df[i], ax=a[n])
plt.savefig('zxc.png') # посмотрим на изображение "ВЫбросы.png"

# Для обработки выбрасов нужно всем пропуски в таблице "пол" заменить на "Пол не указан"
df['пол'] = df['пол'].fillna('Пол не указан')


# Создадим функцию emissions, которая будет отчищать данные от выбросов
def emissions(zxc):
    # Методом 3IQR для работы с выбросами.
    for i in ['утепление', 'температура_воздуха_в_помещении', 'скорость_воздуха', 'рост',
              'среднемесячная_температура_на_улице']:
        Q1, Q3 = zxc[i].quantile([0.25, 0.75])
        IQR = Q3 - Q1
        zxc = zxc[(zxc[i] >= Q1 - 1.5 * IQR) & (zxc[i] <= Q3 + 1.5 * IQR)]
    return zxc


df[['утепление', 'температура_воздуха_в_помещении', 'скорость_воздуха', 'рост',
    'среднемесячная_температура_на_улице']] = emissions(df[['утепление', 'температура_воздуха_в_помещении',
                                                            'скорость_воздуха', 'рост',
                                                            'среднемесячная_температура_на_улице']])
# Рассмотрим графики без выбросов

f, a = plt.subplots(1, 5, figsize=(22, 10))
for n, i in enumerate(['утепление', 'температура_воздуха_в_помещении', 'скорость_воздуха', 'рост',
                       'среднемесячная_температура_на_улице']):
    sns.boxplot(y=df[i], ax=a[n])
plt.savefig('zxc2.png') # посмотрим на изображение "Выбросы_удалены.png"

#

# 5.Провести аналитический и графический анализ данных.
# Проводя аналитический анализ данных была найдена зависимость столбца "способ охлаждения" и "окно".
f, a = plt.subplots(1, 1, figsize=(10, 5))
sns.scatterplot(x=df['способ_охлаждения'], y=df['окно'])
plt.savefig('klimat.png')  # посмотрим на изображение "Klimat.png"
# Проанализировав график на картинке (klimat.png) можно сделать вывод, что кондиционирования зависит от состояния окна.
# Только в случае когда окно закрыто используется способ охлаждения "Кондиционирования".


# 6.обработка пропусков - отдельная ячейка
# 1.Заполним пропуски необходимых нам столбцах. Столбцы "Вес" и "Рост" мы заменим медианным значением, учитывая пол респондента.
# Так как у многих респондентов столцеб "Пол" полностью отсутствует(пропуски в столбеце "Пол" не могут обработаны), мы заполнили его значением "Пол не указан".
# Респондентов с данным значением в столбце "Пол", мы заполним общей медианной столбца.
# 2."Температура воздуха в помещении" и "Оценкаскомфорта" мы заполняем общей медианной по способу охлаждения.


print(df['рост'])
# 1
for i in ['Женский', 'Мужской']:
    df.loc[((df['пол'] == i) & (df['вес'].isnull())), 'вес'] = df['вес'].fillna(df['вес'].describe().median())
    df.loc[((df['пол'] == i) & (df['рост'].isnull())), 'рост'] = df['рост'].fillna(df['рост'].describe().median())
df.loc[df['пол'] == 'Пол не указан', 'рост'] = df['рост'].fillna(df['рост'].describe().median())

# 2
for j in ['Кондиционирование', 'Вентиляция', 'Смешанный', 'NA']:  # зависит от способа охлаждения
    df.loc[((df['способ_охлаждения'] == j) & (df['оценка_комфорта'].isnull())), 'оценка_комфорта'] = (
        df['оценка_комфорта'].fillna(df['оценка_комфорта'].describe().mean()))
    df.loc[((df['способ_охлаждения'] == j) & (df['температура_воздуха_в_помещении'].isnull())),
    'температура_воздуха_в_помещении'] = (df['температура_воздуха_в_помещении'].fillna(
        df['температура_воздуха_в_помещении'].describe().mean()))


df1 = df  # рабочий момент :) :) :) :)


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Дополнительный категориальный столбец - количество_рекламаций_категории - отдельная ячейка

# Создаем функцию для создания нового столбца "количество_рекламаций_кат" (Категириальный тип данных)
def qwe(x):
    if x <= 1:
        return 'мало'
    elif x == 2:
        return 'средне'
    elif x > 2:
        return 'много'


df1['количество_рекламаций_кат'] = [qwe(i) for i in df1['количество_рекламаций']]


# дополнительный категориальный столбец - возраст_категории - отдельная ячейка

# Создаем функцию для создания нового столбца "возраст_кат" (Категириальный тип данных)
def zxc(z):
    if z <= 44:
        return 'молодой возраст'
    elif 45 <= z <= 59:
        return 'средний возраст'
    elif z > 60:
        return 'пожилой возраст'


df1['возраст_кат'] = [zxc(i) for i in df1['возраст']]

# средний возраст респондентов по полу и стране - отдельная ячейка
q1 = df1[['страна', 'пол', 'возраст']].groupby(['страна', 'пол']).mean()
print(q1.round())

# Рассчитать среднюю комфортную температуру в зависимости от возрастной категории - отдельная ячейка

# Так как не указано какой комфортной температуры воздуха идет речь, мы возьмем комфортную температуру в помещении
# Рассчет средней комфортной температуры в зависимости от возрастной категории - отдельная ячейка
df3 = df1[['температура_воздуха_в_помещении', 'оценка_комфорта', 'возраст_кат']]
df3 = df3.loc[df3['оценка_комфорта'] == 6]
q2 = df3.dropna().groupby(['возраст_кат', 'оценка_комфорта']).mean()
print(q2.round())
#

# Медианное значение температуры и влажности для каждого типа охлаждения - отдельная ячейка
q3 = df1[['температура_воздуха_в_помещении', 'rh', 'способ_охлаждения']].groupby(['способ_охлаждения']).median()
print(q3.round())
print(df3.dropna().groupby(['возраст_кат', 'оценка_комфорта']).mean())
#
